### 数据库进阶



#### MYSQL锁 

##### 读写锁

在处理并发请求的时候，Mysql通过实现两种类型的锁组成的锁系统来解决问题，这两种类型的锁通常被称为**共享锁**和**排他锁**，也叫**读锁**和**写锁**。读锁是共享的，相互不阻塞，多个客户在同一时刻可以读取同一个资源而互不干扰。写锁是排他的，也就是说写锁会阻塞同其他的写锁和读锁，只有这样才能保证给定的时间内，只有一个用户才能执行写入。

##### 锁粒度

一种提高并发能力的方式是让锁定对象更有选择性，尽量**只锁定需要修改的部分**。在给定的资源上，锁定的数据越少，系统的并发程度就越高。

- 表锁 ：这是一种最基本的锁策略，也是开销最小的策略。在一个用户进行写操作之前需要先获得写锁，这会**阻塞其他用户对该表的所有读写操作**。

- 行锁：行级锁可以最大程度地支持并发操作，但带来了最大的锁开销。行级锁只在存储引擎层实现。

  手动添加行锁在select * from table where 字段 =  ?  for update;

**<u>实验MyIsam的表锁：</u>**

- 读锁：lock table table1 read; 给table1表加上读锁 ，不同的session都可以读，但包括本session都不能写入该表，本Session会提示被读锁阻止写入，并且不能读其他的表。其他的Session会阻塞写入请求，直到uBnlock。
- 写锁：lock table table2 write; 给table2表加上写锁，本Session可以读写table2，不能读写其他的表；其他的session对该表的查询操作被阻塞。

总结：MyISAM表级锁有两种

- 表共享读锁
- 表独占写锁

![image-20201010201809656](C:\Users\Voyager\AppData\Roaming\Typora\typora-user-images\image-20201010201809656.png)

![image-20201010201853017](C:\Users\Voyager\AppData\Roaming\Typora\typora-user-images\image-20201010201853017.png)

简而言之：读锁会阻塞写但不会阻塞读。而写锁会阻塞写和读



<u>**实验InnoDB的表锁**</u>：

在一个事务中update某一行数据但未提交，然后再另外一个事务中修改同一行数据时会被阻塞。第一个事务提交之后第二个事务才会提交。

##### **行锁变成表锁**  

###### 索引失效

varchar类型不加单引号去做条件修改，这也是索引失效的情况，sql可以通过但是会将行锁变成表锁，sql提交commit之后，表锁解除。

###### 间隙锁

![image-20201010210014250](image\1)

![image-20201010210045355](image\2)

给不存在的a=2行加上了锁，阻塞了其他事务新增a=2的操作。这就是间隙锁。

间隙锁定义：当我们用的范围条件而不是相等条件检索数据，并请求求共享或者排他锁时，InnoDB会给符合条件的已有数据的索引项加锁，对于再条件范围内但并不存在的记录，叫做“间隙”。间隙被锁定时，无法插入在间隙上插入数据。

#### 事务

##### ACID

- 原子性：一个事务是不可分割的最小工作单元，整个事务要么全部提交成功，要么全部失败回滚。

- 一致性：数据库总是从一个一致性的状态转换到另外一个一致性的状态。

- 隔离性：**通常来说**，一个事务所作的修改在提交以前，对其他的事务是不可见的。（这里还要讨论隔离级别。）

- 持久性：一旦事务提交，则其所作的修改就会永久保存到数据库中。

#### 数据库隔离级别 

##### 四种隔离级别

- 未提交读Read Committed: 事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的的数据，这也被称为**脏读**。

- 提交读Read Committed：这是大多数的数据库系统的隔离级别，但Mysql不是。一个事务只能看到已经提交的事务所做的修改。这个级别有时候也叫**不可重复读**，因为两次执行同样的查询**可能会得到不一样的结果。**

- 可重复读Repeated Read：事务级别。解决了脏读的问题。该级别保证了在**同一个事务**中多次**读取同样的记录的结果是一致的**。理论上这一隔离级别不保证防止幻读，但mysql在这一隔离级别解决了幻读。幻读指的是在某个事务读取一个范围内的记录时，另外一个事务在该范围内**插入**了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行。InnoDB和XtraDB存储引擎通过**多版本并发控制（MVCC）解决了幻读**的问题。

- 可串行化Serializable：最高的隔离级别，通过强制事务串行执行，避免了幻读的问题。简单来说，Serializable会在读取的每一行数据上都加锁。所以可能导致大量的超时和锁争用，实际应用中很少会用。

还有一种问题是<u>更新丢失</u>： 两个或多个事务对同一行进行修改，由于事务不知道其他事务的存在，就会发生最后的更新覆盖其他事务的更新的情况。行锁就可以避免该问题。



<u>注意不可重复读和幻读之间的区别：</u>两者很相似但侧重点不同。

（主要针对的是**update**/delete）<u>对自己未操作过的数据多次读取，结果出现了不一致或者记录不存在的情况。</u>破坏了隔离性

（主要针对的是insert）<u>对自己未操作过的数据进行了多次读取，第一次数据不存在，第二次数据出现了，这就是幻行。</u>



- MySQL `REPEATABLE READ` 隔离级别如何防止 `脏读` 和 `幻读` ？

对于普通的 `无锁读` 语句， `REPEATABLE READ` 隔离级别防止 `脏读` 的原理和 `REPEATABLE READ` 是一样的，都是基于 `MVCC` ，只不过 `REPEATABLE READ` 事物内的 `SELECT` 语句每次不是读取最新的已提交快照，而是读取的第一次已提交快照，因此也防止了 `幻读` 。

- 对于 `REPEATABLE READ` 隔离级别，事物内部执行的语句除了普通的 `无锁读` ，肯定也还存在 `带锁读` ，比如 `SELECT FOR UPDATE语句` 、 `UPDATE语句` 、 `DELETE语句` ，这种带锁读对阻塞其他事物的 `INSERT` 么？

答案是阻塞，该隔离级别开启了 `间隙锁` ，因此会阻塞对 `SELECT FOR UPDATE` 语句选中的记录进行更新、删除，阻塞对选中的范围间隙进行插入。

#### 索引

##### 为什么是B+树

B+树是由B树改造过来的有若干不同：

- B-Tree数据结构中的非叶节点是key-value结构，即有索引也有存放的数据。B+树的非叶节点只存放索引。
- B+树的叶子节点包含所有的索引字段
- B+Tree的叶子节点用指针相连，提高了**区间搜索**的性能。如果是原来B-Tree，由于叶子节点没有用指针链接，因此区间搜索性能不好。

##### 索引失效情况

using filesort文件内排序

using temuporary 产生了临时表，常见于排序order by和分组查询group by

<u>索引失效或者无索引还会导致行锁变成表锁</u> varchar类型不加单引号去做条件修改，sql可以通过但是会变成表锁，commit之后，表锁解除。

##### 排序算法

- 双路排序 两次扫描磁盘最终得到数据：读取行指针和orderby列进行排序，然后扫描已经排序好的列表按照列表中的值读取；从磁盘中取排序字段，在buffer中排序，再从磁盘取其他的字段
- 单路排序 

##### 聚集索引和非聚集索引

###### 为什么innoDB必须有主键,并且推荐使用整型的自增主键？

第一个问题，InnoDB会建立一个唯一索引，如果设置了主键，InnoDB会选择主键建立唯一索引，如果没有则会选择第一个不含null值的唯一索引作为主键索引，如果没有这样的唯一索引则会内部创建一个自增序列作为唯一索引。

第二个问题，如果主键非递增，那么以主键组织的索引维护成本就很高了，因为会频繁破环B+树的平衡性，导致多次的重平衡操作，性能开销很大。



##### explain 模拟执行优化器

**重点是 id type key rows Extra**  

具体字段的意义：https://blog.csdn.net/jiadajing267/article/details/81269067

##### 慢Sql定位

- 开启慢查询日志，设定一个阈值，将慢sql抓取出来
- explain+慢sql的分析
- show profile查询sql在mysql服务器里面的执行细节和生命周期情况
- 服务器的参数调优



##### 建立索引

- 左连接left join：左边都要，因此索引建在右边； 右连接right join：右边都要，索引建在左边
- 全值索引最优：按照建立的索引顺序查找并且索引全部用上
- 最左前缀法则：查询从索引的最左前列开始而且不跳过索引中的列。中间的索引不能断。
- like 查询%放右边。 如果必须使用%value%则使用<u>覆盖索引</u>：用建立索引的字段查询，尽量全覆盖
- 不要在sql中存在任何计算，**varchar的单引号不要忘记加** 尽量不要加入or
- order by 如果没有按照索引的顺序，一般都会产生filesort
- group by分组，基本上都需要排序，如果没有按照索引的顺序，会有临时表产生

##### 一般性建议

- 对于单值索引，尽量选择针对当前query过滤性更好的索引
- 在选择组合索引的时候，当前Qurey中过滤性最好的字段应该放在最左边

注意：Mysql会进行sql的优化，假设索引建立的顺序是c1c2c3c4，全值-覆盖索引查询的顺序是c4c3c2c1，底层会进行顺序的调整，与顺序无关。

##### 最左匹配原则

就是索引的使用要按照索引建立的顺序从左至右使用，若中间被范围中断，则无法完全利用好索引

https://www.cnblogs.com/lanqi/p/10282279.html

##### 索引口诀

全值匹配我最爱，最左前缀要遵守；
带头大哥不能死，中间兄弟不能断；
索引列上少计算，范围之后全失效；
Like百分写最右，覆盖索引不写星；
不等空值还有or，索引失效要少用；
VAR引号不可丢，SQL高级也不难！



#### MVCC原理与实现

多版本并发控制。好处，相信也是耳熟能详：读不加锁，读写不冲突。

MVCC（Multi-Version Concurrent Control），即多版本并发控制协议，它的目标是在保证数据一致性的前提下，提供一种高并发的访问性能。在MVCC协议中，每个用户在连接数据库时看到的是一个具有一致性状态的镜像，每个事务在提交到数据库之前对其他用户均是不可见的。当事务需要更新数据时，不会直接覆盖以前的数据，而是生成一个新的版本的数据，因此一条数据会有多个版本存储，但是同一时刻只有最新的版本号是有效的。因此，读的时候就可以保证总是以当前时刻的版本的数据可以被读到，不论这条数据后来是否被修改或删除。

innodb会为每一行添加两个字段，分别表示该行**创建的版本**和**删除的版本**，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别下具体各种数据库操作的实现：

-  select：满足以下两个条件innodb会返回该行数据：

  （1）该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。

  （2）该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。

-  insert：将新插入的行的创建版本号设置为当前系统的版本号。

-  delete：将要删除的行的删除版本号设置为当前系统的版本号。

-  update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。

 其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。

 由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。

 通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。

参考：https://yq.aliyun.com/articles/283418

#### Innodb和MyISAM引擎区别

- MyIsam不支持事务，Innodb支持事务

- MyIsam的锁是表锁，并发度低，InnoDb用的是行锁，适用于高并发

  

#### 主从复制

![image-20201010213209910](image\3)



master 将改变记录到二进制日志（binary log）。 这些记录过程叫做二进制日志事件， binary log events；

slave 将 master 的 binary log events 拷贝到它的中继日志（relay log）；    

slave 重做中继日志中的事件， 将改变应用到自己的数据库中。 MySQL 复制是异步的且串行化的  

#### 三大范式

第一范式(确保每列保持原子性)

第二范式(确保表中的每列都和主键相关)  主要针对联合主键

第三范式(确保每列都和主键列直接相关,而不是间接相关) 也就是消除传递依赖

https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html

